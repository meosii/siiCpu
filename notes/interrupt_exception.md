## 1. 中断异常处理流程

### 1.1 当一个 hart 遇到异常的情况，硬件会执行以下的步骤：

1. 保存异常发生前的权限模式到 `mstatus.MPP` 中，并将权限模式切换到 M 模式。然后，保存异常发生前的 `mstatus.MIE` 到 `mstatus.MPIE` 中，并将 `mstatus.MIE` 清零以屏蔽中断。这说明 RISC-V 的硬件不支持中断的嵌套，如果要实现中断的嵌套，只能通过软件来完成。
2. 根据异常的来源设置 `mcause` 的值，并将异常的相关信息写入 `mtval` 中。
3. 将异常指令的 PC 保存到 `mepc` 中，并将 PC 设置为 `mtvec` 中指定的异常处理程序的入口地址。对于同步异常，`mepc` 指向导致异常的指令；对于中断，`mepc` 指向中断发生后应该继续执行的位置，通常是中断指令的下一条指令地址，即 `mepc + 4`。此外，`mtvec` 有两种模式：直接模式和向量模式。直接模式下，直接跳转到 `mtvec` 的基地址执行；向量模式下，根据 `mcause` 的中断类型跳转到相应的中断处理程序的首地址执行。
4. 执行异常处理程序，并在程序中保存和切换上下文环境。
5. 当异常处理程序执行完毕后，在程序末尾会调用 MRET 指令来退出异常处理程序，S 模式下调用的是 SRET 指令。
6. 执行 MRET 指令后，处理器硬件会做以下操作：更新 `mstatus`。将异常发生前的 `mstatus` 的状态恢复，将 `mstatus.MPIE` 复制到 `mstatus.MIE` 来恢复之前的中断使能设置，并将权限模式设置为 `mstatus.MPP` 域中的值。从 `mepc` 中保存的地址继续执行，即回到异常发生前的程序流继续执行。

### 1.2 操作系统会执行如下步骤：

1. 保存异常发生时的上下文，即将 cpu 内部通用寄存器保存到内存的栈中。
2. 查询 `mcause` 寄存器的异常以及中断编号，跳转到适合的异常处理程序。
3. 执行完异常处理程序后，恢复栈中寄存器内容到寄存器中。
4. 执行 MRET 指令，返回异常现场。

![](https://tinylab.org/wp-content/uploads/2022/03/riscv-linux/images/riscv-irq-pipeline-introduction/irq_pipeline.png)

## 2. cpu 设计中的处理

对于异常中断的发生，处理器内部有专门的寄存器保存异常发生的状态等信息，本设计仅支持机器模式，包含以下 CSR 寄存器：

- mtvec: 存放异常发生时 pc 的跳转地址，可以由软件配置为直接模式或向量模式
- mepc: 存放异常发生时的 pc 值，用于异常返回时恢复执行
- mcause: 存放异常的原因码，用于区分不同的异常类型
- mie: 存放全局中断使能位，用于控制中断的开关
- mip: 存放中断挂起位，用于标识哪些中断已经触发
- mtval: 存放异常相关的附加信息，如地址或指令
- mscratch: 存放一个临时寄存器，用于保存一些中间值或上下文
- mstatus: 存放一些状态位，用于控制异常处理的行为，如特权级、委托、栈指针等

对于 CSR 寄存器的读写包括硬件的直接读写以及软件通过指令的读写：1. 异常产生时，硬件需要保存当前异常相关状态；2. 软件在中断处理程序中，保存和恢复处理器状态；在操作系统内核中，管理进程和线程的上下文切换；以及在调试器中，以读取和修改处理器状态。

因此，需要考虑两者的读写操作是否会产生冲突，当异常发生时（考虑五级流水线设计，异常的发生必然是一些指令正在执行过程中，就要考虑哪一条指令存放到 `mepc` 中），比如发生了 ECALL 指令，那么异常的产生在译码阶段，mepc 也必然是该条指令（后续为了避免跳回该异常指令，软件会在异常处理代码中实现 `mepc + 4`），而对于处于 EX，MEM，WB 阶段的指令还未完全执行完毕，通用寄存器的值还未写入（异常指令之前的指令要执行完毕，保存到栈中的上下文内容才正确），因此在此等到异常指令到达 WB 阶段，再进行 pc 的跳转，并且将异常指令之后的流水线全部清空，为了异常指令的后一条指令不会正确执行到 MEM 阶段，在异常译码时，就可以刷新异常指令之后的流水线。同理，对于其他形式的异常，均等到异常指令到达 MEM 阶段再进行跳转。

对于中断，由于外部中断请求是异步信号，与内部流水线中的指令没有相互关系，当检测到异常指令时，直接对 `mip` 寄存器进行写入操作，硬件通过判断 `mip`，`mie`，`mstatus` 中的 mie 来判断是否进入中断处理程序，此时要保存的 `mepc` 选为当前处理完的 MEM 阶段的指令（由于该指令执行完了，实际上存放该 pc + 4）。

除进入 trap 时的硬件操作外，还有当执行到 MRET 时，硬件需要将 `mstatus` 恢复。

以上操作为硬件对 CSR 寄存器的读取情况，无论此时的指令是什么，都会执行以上操作，因此，软件读写 CSR 的优先级会小于硬件。

在此硬件对 CSR 寄存器的读写不需要采用类似存储器的读写地址数据端口，读操作直接将需要的寄存器，如 `mie`，`mtvec`等直接以端口形式给到 cpu 的控制模块，写操作直接将各个寄存器的写使能给到 always 块中。而对于软件的读写，则是在译码阶段，对 CSR 提供读写的地址以及数据，采用统一的 addr 和 data 输入端口。对于 csrrw 等特权指令，需要考虑的，在五级流水线的什么时候写入 CSR，什么时候写入通用寄存器，由于 csrrw 等特权指令前后会其他一般指令，也会对寄存器进行读写操作，那么对于顺序写入的处理器来说，将寄存器的写入均安排在流水线的 WB 阶段，而 CSR 寄存器，只需要保证 CSR 的写入按特权指令的顺序，因此，在译码阶段就可以进行 CSR 的写操作。

其中对于通用寄存器的读，由于第二阶段读，第五阶段写，必然会产生数据冒险，在此选用数据直通与暂停流水线来解决，而 CSR 读写均在第二阶段执行，读为组合读，写为一周期写入，不会发生数据冒险的情况。